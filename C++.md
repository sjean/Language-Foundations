
# C/C++ 
**一定要弄懂c++的内存分配机制，父类，子类继承时的内存如何分配，封装、继承、多态、虚函数的实现机制和原理。**

### 1. malloc/free与new/delete的区别
malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。
### 2. C++  string *str ;和string *str=new string ;的区别 

1 前者只是定义了一个指针变量，叫str，并没有赋值，此时是个野指针，指向的内存空间不确定<br>
2 后者是先在申请一段内存空间，然后把这段内存空间的地址赋值给指针变量str
### 3. vector、deque、list、set、map区别
 **1、vector**
相当于数组。在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。

优点：
(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()
(2) 随机访问方便，即支持[ ]操作符和vector.at()
(3) 节省空间。

缺点：
(1) 在内部进行插入删除操作效率低。
(2)只能在vector的最后进行push和pop，不能在vector的头进行push和pop。
(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放

**2、list**
双向链表。每一个结点都包括一个信息块Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。

优点：
(1) 不使用连续内存完成动态操作。
(2) 在内部方便的进行插入和删除操作
(3) 可在两端进行push、pop

缺点： 
(1)不能进行内部的随机访问，即不支持[]操作符和vector.at() 
(2)相对于verctor占用内存多

**3、deque**
双端队列 double-end queue 
deque是在功能上合并了vector和list。

优点：
(1) 随机访问方便，即支持[ ]操作符和vector.at()
(2) 在内部方便的进行插入和删除操作
(3) 可在两端进行push、pop
缺点：

(1) 占用内存多

**使用区别：**

（1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
（2）如果你需要大量的插入和删除，而不关心随即存取，则应使用list
（3）如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque

**4、map是，key-value对集合**

**5、set，就是key=value的map**

### 4. STL的六大组件
- 容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；
- 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；
- 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；
- 仿函数（Function object，仿函数(functor)又称之为函数对象（function object），其实就是重载了()操作符的struct，没有什么特别的地方
- 迭代适配器（Adaptor）
- 空间配制器（allocator）其中主要工作包括两部分 1.对象的创建与销毁    2.内存的获取与释放
 [for more](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html)
 
### 5. c++ volatile
 volatile 的确切含义与具体机器相关，可以通过阅读编译器文档来理解，使用volatile的程序在移到新的机器或编译器时通常必须改变。
与 const 限定符相同的，volatile 也是类型限定符。
与 const 类似的是，只能将 volatile 对象的地址赋给指向 volatile 的指针，或者将指向 volatile 类型的 volatile 类型的指针复制给指向 volatile 的指针。只有当引用为 volatile 时，才可以使用 volatile 对象对引用进行初始化。

### 6. 虚基类的作用是什么，虚基类的实现机制就是什么呢？
虚基类的作用是在C++多重继承的情况下，如果出现菱形继承的话，为了消除在子类中出现父类数据实体的多份拷贝。

虚基类的实现机制这个有点复杂。不同编译器内部实现的机制也不相同。其主要有两种实现方案： 
（1）是引入virtual base class table，不管多少个虚基类，总是只有一个指针指向它，这个virtual base class table(VBTBL)包括真正的 virtual base class 指针。

（2）Bjarne的办法是在virtual function table中放置virtual base class的offset，而非地址，这个offset在virtual function table 的负位置(正值是索引virtual function，而负值则将方向盘引到virtual base class offsets)。

在VC++中，采用的是类似第一种方案。对每个继承自虚基类的类实例，将增加一个隐藏的“虚基类表指针”（vbptr）成员变量，从而达到间接计算虚基类位置的目的。该变量指向一个全类共享的偏移量表，表中项目记录了对于该类而言，“虚基类表指针”与虚基类之间的偏移量”，而不是真正的 virtual base class 指针，这就是说类似于上面的第一种方案，而非严格按照该方案。具体参见C++虚继承对象的内存布局。

对于g++，实现上和VC++不同，它并没有生成独立的虚基类表和虚基类表指针来指明虚基类的偏移地址，具体实现细节我还不太清楚，可能《深度探索c++对象模型》会有说明。这是只是测试了当子类存在虚函数表指针和虚函数表时，编译器并不会为子类对象实体生成额外的一个虚基类表指针。

但是当子类没有虚函数表指针时，编译器会为子类对象生成一个指针变量，这个指针变量很可能就是指向虚基类表。种种迹象表明g++的实现方案和上面提到的第二种方案很相似，具体我没有深入研究其对象布局，以后再探讨我猜测的真伪。

### 7. C++的单例模式

```
class CSingleton  
{  
private:  
    CSingleton()   //构造函数是私有的  
    {  
    }  
    static CSingleton *m_pInstance;  
public:  
    static CSingleton * GetInstance()  
    {  
        if(m_pInstance == NULL)  //判断是否第一次调用  
            m_pInstance = new CSingleton();  
        return m_pInstance;  
    }  
};  
```

### 8. define 和 typedef 的区别
define是宏定义，在预处理阶段进行字符串替换。 
typedef是关键字，声明类型别名，在编译时处理（增加可读性）。

### 9. C++ 虚函数表解析

**1. 概念**
	C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。
对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。这里我们着重看一下这张虚函数表。C++的编译器应该是保证：虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。


 **一般继承（无虚函数覆盖）**
![enter image description here](http://img.blog.csdn.net/20160325105602334)                ![enter image description here](http://img.blog.csdn.net/20160325105634357)
1）虚函数按照其声明顺序放于表中。
2）父类的虚函数在子类的虚函数前面。

**一般继承（有虚函数覆盖）**
![enter image description here](http://img.blog.csdn.net/20160325105804469)  ![enter image description here](http://img.blog.csdn.net/20160325105832235)
1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
2）没有被覆盖的函数依旧。

**多重继承（无虚函数覆盖）**
![enter image description here](http://img.blog.csdn.net/20160325105935272)  ![enter image description here](http://img.blog.csdn.net/20160325110637994)
1） 每个父类都有自己的虚表。
2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

**多重继承（有虚函数覆盖）**
![enter image description here](http://img.blog.csdn.net/20160325110933729)  ![enter image description here](http://img.blog.csdn.net/20160325110955542)

```
  Derive d;
    Base1 *b1 = &d;
    Base2 *b2 = &d;
    Base3 *b3 = &d;
    b1->f(); //Derive::f()
    b2->f(); //Derive::f()
    b3->f(); //Derive::f()

    b1->g(); //Base1::g()
    b2->g(); //Base2::g()
    b3->g(); //Base3::g()
```

**1、多态**

概念：

多态性就是指同样的消息被类的不同的对象接收时导致的完全不同的行为的一种现象。这里所说的消息即对类成员函数的调用。多态实质是一个函数名称的多种形态。

C++两种类型多态：

（1）编译时多态是通过静态联编实现的；

（2）运行时多态则是通过动态联编实现的。

函数联编：

对一个函数的调用，在编译或运行时确定将其连接到相应的函数体的代码，实质是把一个标示名与一个存储地址（函数代码段入口）联系在一起的过程。

**2、虚函数**

C++中的动态联编是通过虚函数实现的，虚函数必须存在于继承的环境下。

当一个类的成员函数说明为虚函数后，就可以在该类的（直接或间接）派生类中定义与其基类虚函数原型相同（注意是函数原型一定要完全相同，否则会隐藏该虚函数）的函数。

虚函数可以在一个或多个派生类中被重新定义，要求在派生类中重新定义时，必须与基类中的函数原型完全相同，包括函数名、返回类型、参数个数和参数类型的顺序。这时无论在派生类的相应成员函数前是否加上关键字virtual，都将视其为虚函数，如果函数原型不同，只是函数名相同，C++将视其为一般的函数重载，而不是虚函数。只有类的成员函数才能声明为虚函数，全局函数及静态成员函数不能声明为虚函数。

**3、纯虚函数**

纯虚函数是在基类中只声明虚函数而不给出具体的函数定义体，将它的具体定义放在各派生类中，称此虚函数为纯虚函数。

通过该基类的指针或引用就可以调用所有派生类的虚函数，基类只是用于继承，仅作为一个接口，具体功能在派生类中实现.

纯虚函数的声明如下：（注：要放在基类的定义体中）

```
   virtual 函数原型=0；
```

**注意：**

（1）声明了纯虚函数的类，称为抽象类；

（2）抽象类中可以有多个纯虚函数；

（3）不能声明抽象类的对象，但可以声明指向抽象类的指针变量和引用变量；

（4）抽象类也可以定义其他非纯虚函数；

（5）如果派生类中没有重新定义基类中的纯虚函数，则在派生类中必须再将该虚函数声明为纯虚函数；

（6）从抽象类可以派生出具体或抽象类，但不能从具体类派生出抽象类（这条在vs2012上实验是错误的，详见后面代码）；

（7）在一个复杂的类继承结构中，越上层的类抽象程度越高，有时甚至无法给出某些成员函数的实现，显然，抽象类是一种特殊的类，它一般处于类继承结构的较外层；

（8）引入抽象类的目的，主要是为了能将相关类组织在一个类继承结构中，并通过抽象类来为这些相关类提供统一的操作接口。

```
class Base {
public:
    void f() { cout << "Base::f" << endl; }

};

class Base2 : public Base{
public:
    virtual void g()=0;
};

class Derive : public Base2{

public:
    void g() { cout << "Derive::g" << endl; }
};

int main() {
    Base2 *b2 = new Derive;

    b2->f();
    b2->g();

    return 0;
}
```
最后输出： 
Base::f 
Derive::g
说明也可以从具体类派生抽象类。


### const和static的作用 
static关键字：

1）函数体内static变量的作用范围为函数体。不同于auto变量。该变量的内存只被分配一次。因此其值在下次调用时仍维持上次的值。

2）在模块内的static全局变量可以被模块内的所有函数访问。但不能被模块外的其他函数访问。

3）在模块内的static函数只可被这一模块内的其它函数调用。这个函数的使用范围被限制在声明它的模块内。

4）在类中的static成员变量属于整个类所有，对类的所有对象只有一份复制。

5）在类中的static成员函数属于整个类所有，这个函数不接受this指针，因而只能访问类的static成员变量。

const关键字：

1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化。因为以后就没有机会再改变它了。

2）对指针来说，可以指定指针的本身为const，也可以指定指针所指向的数为const。或二者同时为const。

3）在一个函数的声明中，const可以修饰形参，表明它是一个输入参数。在函数内不能改变其值。

4）对于类的成员函数，若指定其为const类型。则表明其是一个常量函数。不能修改类的成员变量。

5）对于类的成员函数，有时候必须指定其返回值为const类型。以使得其返回值不为“左值”。

### 指针和引用的区别
    1. 指针是一个实体，而引用仅是个别名；
    2. 引用使用时无需解引用（*），指针需要解引用；
    3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
    4. 引用没有 const，指针有 const，const 的指针不可变；
    5. 引用不能为空，指针可以为空；
    6. “sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小；
    7. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域

### malloc和new的区别
**（1）操作对象有所不同。**
malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。对于非内部数据类的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。
**（2）用法上也有所不同。**
函数malloc 的原型如下：void * malloc(size_t size);
用malloc 申请一块长度为length 的整数类型的内存，程序如下：
int *p = (int *) malloc(sizeof(int) * length);
我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。
1、malloc 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将void * 转换成所需要的指针类型。
2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。
函数free 的原型如下：
void free( void * memblock );
为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free
对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。

### 拷贝构造函数
三种调用拷贝构造函数的情况：
1.  需要用一个对象去初始化同一个类的另一个新对象；
2.  函数调用时，形参和实参的结合
3.  函数返回值为对象时
**浅拷贝和深拷贝**
浅拷贝是指在对象赋值时，只对对象中的数据成员进行简单的赋值，但对于存在动态成员（指针等），就会出现问题，使得两个对象的动态成员指向了同一个地址，而不是不同地址，内容相同。

### 内存管理
![Alt text](./微信截图_20170429101935.png)

栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
常量区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改

### inline函数和宏定义
内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接呗镶嵌到目标代码中。
内联函数要做参数类型检查，这是内联函数跟宏相比的优势。
inline是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。对于短小的代码来说，inline可以带来一定的效率提升，
而且和C时代的宏函数相比，inline更安全可靠。可是这个是以增加空间消耗为代价的。至于是否需要inline函数就需要根据你的实际情况取舍了。
**内联函数与宏定义区别**
  （1）内联函数在编译时展开，宏在预编译时展开；
  （2）内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
  （3）内联函数有类型检测、语法判断等功能，而宏没有；
  （4）inline函数是函数，宏不是；
  （5）宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；
